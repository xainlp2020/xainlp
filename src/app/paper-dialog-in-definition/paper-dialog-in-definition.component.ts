import { Component, Inject, OnInit } from '@angular/core';
import {MatDialog, MAT_DIALOG_DATA} from '@angular/material/dialog';
import {Sort} from '@angular/material/sort';
import {PaperDialogComponent} from "../paper-dialog/paper-dialog.component";


export interface paperData{
  title: string,
  authors: string,
  year: number,
  venue: string,
  main_explainability: string,
  main_visualization: string,
  citation: number,
  link: string,
  placement: string,
  xai_type: string,
  nlp_task_1: string,
  parts_covered: string,
  type: string,
  evaluation_metrics: string,
  operations: string,
  abstract: string,
  id: string,
  num_preview_img: number,
  similarity: number,
  similarity_explanation: string
}

interface refined_list {
  [index: number]: { paperData };
}


@Component({
  selector: 'app-paper-dialog-in-definition',
  templateUrl: './paper-dialog-in-definition.component.html',
  styleUrls: ['./paper-dialog-in-definition.component.css']
})
export class PaperDialogInDefinitionComponent implements OnInit {

  listOfPapers;
  listOfPapers_sorted;
  constructor(@Inject(MAT_DIALOG_DATA) public data: refined_list, public dialog: MatDialog) { 
    this.listOfPapers = data

    this.listOfPapers_sorted = this.listOfPapers.sort((a, b) => {
      return this.compare(a.year, b.year, false);
    });
    // console.log(this.listOfPapers_sorted)
  }

  viewPaper(selectedPaper) {
    this.dialog.open(PaperDialogComponent, {
      data: selectedPaper
    });
  }

  explainability_def = {
    "Feature Importance": 'Prediction explanations are derived from the \
                          importance scores of different features used in the NLP model to output the final prediction.',
    "Surrogate Model": "Explains model predictions by learning a second model, which is usually more \
                          explainable than the original model, as a proxy.",
    "Example-driven": 'A particular prediction of an input instance is explained by identifying and presenting \
                      other instances, usually from available labeled data, that are semantically similar to the input instance.',
    "Provenance": 'The explanation is an illustration of the entire prediction derivation process, which is an intuitive \
                  and effective explainability technique when the final prediction consists of a series of reasoning steps. ',
    "Induction": 'Explanations are generated by inducing human-readable representations, such as rules, trees and programs.'
  }
  visualization_def = {
    "SALIENCY": "Saliency has been primarily used to visualize the importance scores of different types of elements in XAI learning systems.",
    "NATURAL LANGUAGE": "The explanationis verbalized in human-comprehensible natural language",
    "RAW DECLARATIVE": "This visualization technique directly presents the learned declarative representations, such as logic rules, trees, and programs.",
    "RAW EXAMPLES": "This visualization technique is main for presenting example-driven explanations by showing the raw examples.",
    "OTHER": "Other miscellaneous visulziation techniques, such as statistic charts."
  }
  getPlainDefinition(technique_type, name)
  {
    if (technique_type==="explainability")
    {
      return this.explainability_def[name];
    }
    else
    {
      return this.visualization_def[name.toUpperCase()]
    }
  }

  compare(a: number | string, b: number | string, isAsc: boolean) {
    return (a < b ? -1 : 1) * (isAsc ? 1 : -1);
  }

  sortData_selected(sort: Sort) {
    const data = this.listOfPapers_sorted.slice();
    if (!sort.active || sort.direction === '') {
      this.listOfPapers_sorted = data;
      return;
    }

    this.listOfPapers_sorted = data.sort((a, b) => {
      const isAsc = sort.direction === 'asc';
      switch (sort.active) {
        case 'year': return this.compare(a.year, b.year, isAsc);
        case 'main_explainability': return this.compare(a.main_explainability, b.main_explainability, isAsc);
        case 'main_visualization': return this.compare(a.main_visualization, b.main_visualization, isAsc);
        case 'citation': return this.compare(a.citation, b.citation, isAsc);
        case 'venue': return this.compare(a.venue, b.venue, isAsc);
        default: return 0;
      }
    });
  }

  ngOnInit(): void {
  }

}
